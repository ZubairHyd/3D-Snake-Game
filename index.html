<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevent scrollbars */
            touch-action: none; /* Disable double-tap zoom */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        .touch-btn {
            background-color: rgba(74, 85, 104, 0.7);
            border: 2px solid rgba(45, 55, 72, 0.8);
            border-radius: 20px;
            color: white;
            font-size: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none; /* Prevent text selection on tap */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .touch-btn:active {
            background-color: rgba(113, 128, 150, 0.9);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="game-container"></div>

    <div class="absolute top-0 left-0 p-6 w-full flex justify-between items-start z-10 pointer-events-none">
        <div>
            <h1 class="text-3xl md:text-4xl">3D SNAKE</h1>
        </div>
        <div class="text-right">
            <div id="score" class="text-2xl">SCORE: 0</div>
            <div id="highScore" class="text-lg mt-2">HI: 0</div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-20">
        <div class="bg-gray-800 border-4 border-red-500 rounded-lg p-8 text-center shadow-2xl">
            <h2 class="text-4xl text-red-500 mb-4">GAME OVER</h2>
            <div id="finalScore" class="text-2xl mb-2"></div>
            <div id="newHighScore" class="text-yellow-400 text-xl mb-6 hidden">NEW HIGH SCORE!</div>
            <button id="playAgainBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl transition duration-300">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="md:hidden fixed bottom-8 left-1/2 -translate-x-1/2 z-10 grid grid-cols-3 grid-rows-3 gap-2 w-48 h-48">
        <div class="touch-btn col-start-2 row-start-1" data-key="ArrowUp">▲</div>
        <div class="touch-btn col-start-1 row-start-2" data-key="ArrowLeft">◄</div>
        <div class="touch-btn col-start-3 row-start-2" data-key="ArrowRight">►</div>
        <div class="touch-btn col-start-2 row-start-3" data-key="ArrowDown">▼</div>
    </div>

    <script>
        // --- Basic Setup ---
        const gameContainer = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreElement = document.getElementById('finalScore');
        const newHighScoreElement = document.getElementById('newHighScore');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const touchControls = document.getElementById('touch-controls');

        let scene, camera, renderer, snake, food, light, ambientLight, starfield;
        let cameraLookAtTarget = new THREE.Vector3(0, 0, 0);
        let score = 0;
        let highScore = 0;
        let direction = new THREE.Vector3(1, 0, 0);
        let changingDirection = false;
        let lastUpdateTime = 0;
        let updateInterval = 150; // Initial speed
        const initialSpeed = 150;
        const minSpeed = 60; // Maximum speed
        const speedIncrement = 2.5; // How much faster it gets per food
        const gridSize = 1;
        const boardSize = 20;

        // --- Game Logic ---
        function init() {
            loadHighScore();
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0x808080);
            scene.add(ambientLight);
            light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 20, 10);
            light.castShadow = true;
            scene.add(light);

            // --- Eye-Catchy Board & Background ---
            const gridHelper = new THREE.GridHelper(boardSize, boardSize, 0x00ffff, 0xff00ff); // Cyan and Magenta grid
            scene.add(gridHelper);
            
            const starGeometry = new THREE.SphereGeometry(500, 64, 64);
            const starMaterial = new THREE.MeshBasicMaterial({
                map: createStarTexture(),
                side: THREE.BackSide,
                transparent: true,
            });
            starfield = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starfield);

            const planeGeometry = new THREE.PlaneGeometry(boardSize, boardSize);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            playAgainBtn.addEventListener('click', resetGame);
            
            touchControls.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const button = e.target.closest('.touch-btn');
                if (button) onKeyDown({ key: button.dataset.key });
            }, { passive: false });

            startGame();
        }

        function startGame() {
            snake = [];
            const head = createSnakePart(new THREE.Vector3(0, gridSize / 2, 0), true);
            snake.push(head);
            scene.add(head);
            
            cameraLookAtTarget.copy(head.position);
            updateCamera();
            generateFood();
        }

        function resetGame() {
            snake.forEach(part => scene.remove(part));
            scene.remove(food);

            score = 0;
            scoreElement.textContent = 'SCORE: 0';
            direction.set(1, 0, 0);
            updateInterval = initialSpeed; // Reset speed
            gameOverModal.classList.add('hidden');
            newHighScoreElement.classList.add('hidden');
            
            startGame();
            animate();
        }

        // --- High Score Logic ---
        function loadHighScore() {
            highScore = localStorage.getItem('snake3DHighScore') || 0;
            highScoreElement.textContent = `HI: ${highScore}`;
        }

        function saveHighScore() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snake3DHighScore', highScore);
                highScoreElement.textContent = `HI: ${highScore}`;
                newHighScoreElement.classList.remove('hidden');
            }
        }
        
        // --- Visuals ---
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const context = canvas.getContext('2d');
            context.fillStyle = 'black';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = 'white';
            for (let i = 0; i < 1500; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = Math.random() * 1.2;
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fill();
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createSnakePart(position, isHead = false) {
            const geometry = new THREE.SphereGeometry(gridSize / 2, 16, 16); 
            const material = new THREE.MeshLambertMaterial({ color: isHead ? 0x48bb78 : 0x38a169 });
            const part = new THREE.Mesh(geometry, material);
            part.position.copy(position);
            part.castShadow = true;
            return part;
        }

        function generateFood() {
            const x = Math.floor(Math.random() * boardSize - boardSize / 2);
            const z = Math.floor(Math.random() * boardSize - boardSize / 2);
            const position = new THREE.Vector3(x + 0.5, gridSize / 2, z + 0.5);

            for(const part of snake) {
                if(part.position.distanceTo(position) < gridSize) {
                    generateFood(); return;
                }
            }
            
            const geometry = new THREE.BoxGeometry(gridSize, gridSize, gridSize);
            const material = new THREE.MeshLambertMaterial({ color: 0xe53e3e });
            food = new THREE.Mesh(geometry, material);
            food.position.copy(position);
            food.castShadow = true;
            scene.add(food);
        }

        function moveSnake() {
            const newHeadPos = snake[0].position.clone().add(direction.clone().multiplyScalar(gridSize));
            for (let i = snake.length - 1; i > 0; i--) {
                snake[i].position.copy(snake[i - 1].position);
            }
            snake[0].position.copy(newHeadPos);
            changingDirection = false;
        }

        function checkCollision() {
            const headPos = snake[0].position;
            const halfBoard = boardSize / 2;
            if (headPos.x >= halfBoard || headPos.x < -halfBoard || headPos.z >= halfBoard || headPos.z < -halfBoard) return true;
            for (let i = 1; i < snake.length; i++) {
                if (headPos.distanceTo(snake[i].position) < gridSize) return true;
            }
            return false;
        }

        function checkFood() {
            if (snake[0].position.distanceTo(food.position) < gridSize) {
                score += 10;
                scoreElement.textContent = 'SCORE: ' + score;
                
                if (navigator.vibrate) navigator.vibrate(50);

                // Increase speed
                updateInterval = Math.max(minSpeed, updateInterval - speedIncrement);

                const newPart = createSnakePart(snake[snake.length - 1].position.clone());
                snake.push(newPart);
                scene.add(newPart);
                
                scene.remove(food);
                generateFood();
            }
        }
        
        function updateCamera() {
            if (snake.length > 0) {
                const headPosition = snake[0].position;
                const cameraOffset = new THREE.Vector3(0, 15, 10);
                const targetPosition = headPosition.clone().add(cameraOffset);
                
                camera.position.lerp(targetPosition, 0.08);
                cameraLookAtTarget.lerp(headPosition, 0.08);
                camera.lookAt(cameraLookAtTarget);
            }
        }

        function animate(currentTime) {
            if (gameOverModal.classList.contains('hidden')) {
                requestAnimationFrame(animate);
            } else {
                return;
            }
            
            if (starfield) {
                starfield.rotation.y += 0.0002;
            }

            const deltaTime = currentTime - lastUpdateTime;
            if (deltaTime > updateInterval) {
                lastUpdateTime = currentTime;
                
                moveSnake();
                if (checkCollision()) {
                    finalScoreElement.textContent = `YOUR SCORE: ${score}`;
                    saveHighScore();
                    gameOverModal.classList.remove('hidden');
                    return;
                }
                checkFood();
            }
            
            updateCamera();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (changingDirection) return;

            const key = event.key;
            let newDir = null;

            if (key === 'ArrowUp' && direction.z !== gridSize) newDir = new THREE.Vector3(0, 0, -1);
            else if (key === 'ArrowDown' && direction.z !== -gridSize) newDir = new THREE.Vector3(0, 0, 1);
            else if (key === 'ArrowLeft' && direction.x !== gridSize) newDir = new THREE.Vector3(-1, 0, 0);
            else if (key === 'ArrowRight' && direction.x !== -gridSize) newDir = new THREE.Vector3(1, 0, 0);

            if (newDir && !direction.equals(newDir.clone().negate())) {
                direction = newDir;
                changingDirection = true;
            }
        }

        // --- Start ---
        init();
        animate();
    </script>
</body>
</html>
