<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Snake Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden; /* Prevent scrollbars */
            touch-action: none; /* Disable double-tap zoom */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        .touch-btn {
            background-color: rgba(74, 85, 104, 0.7);
            border: 2px solid rgba(45, 55, 72, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none; /* Prevent text selection on tap */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .touch-btn:active {
            background-color: rgba(113, 128, 150, 0.9);
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="game-container"></div>

    <div class="absolute top-0 left-0 p-6 w-full flex justify-between items-center z-10">
        <h1 class="text-3xl md:text-4xl">3D SNAKE</h1>
        <div id="score" class="text-2xl">SCORE: 0</div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-20">
        <div class="bg-gray-800 border-4 border-red-500 rounded-lg p-8 text-center shadow-2xl">
            <h2 class="text-4xl text-red-500 mb-4">GAME OVER</h2>
            <div id="finalScore" class="text-2xl mb-6"></div>
            <button id="playAgainBtn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg text-xl transition duration-300">
                PLAY AGAIN
            </button>
        </div>
    </div>

    <!-- Touch Controls for Mobile -->
    <div id="touch-controls" class="md:hidden fixed bottom-8 right-8 z-10 grid grid-cols-3 grid-rows-3 gap-4 w-48 h-48">
        <div class="touch-btn col-start-2 row-start-1" data-key="ArrowUp">▲</div>
        <div class="touch-btn col-start-1 row-start-2" data-key="ArrowLeft">◄</div>
        <div class="touch-btn col-start-3 row-start-2" data-key="ArrowRight">►</div>
        <div class="touch-btn col-start-2 row-start-3" data-key="ArrowDown">▼</div>
    </div>

    <script>
        // --- Basic Setup ---
        const gameContainer = document.getElementById('game-container');
        const scoreElement = document.getElementById('score');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreElement = document.getElementById('finalScore');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const touchControls = document.getElementById('touch-controls');

        let scene, camera, renderer, snake, food, light, ambientLight;
        let cameraLookAtTarget = new THREE.Vector3(0, 0, 0); // For smooth camera movement
        let score = 0;
        let direction = new THREE.Vector3(1, 0, 0); // Start moving right (along X axis)
        let changingDirection = false;
        let lastUpdateTime = 0;
        const updateInterval = 150; // milliseconds, controls game speed
        const gridSize = 1;
        const boardSize = 20; // 20x20 grid

        // --- Game Logic ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);

            // Lighting
            ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(10, 20, 10);
            light.castShadow = true;
            scene.add(light);

            // Game Board
            const gridHelper = new THREE.GridHelper(boardSize, boardSize, 0x4a5568, 0x4a5568);
            scene.add(gridHelper);
            const planeGeometry = new THREE.PlaneGeometry(boardSize, boardSize);
            const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            playAgainBtn.addEventListener('click', resetGame);
            
            // Touch control listener
            touchControls.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent screen scrolling/zooming
                const button = e.target.closest('.touch-btn');
                if (button) {
                    const key = button.dataset.key;
                    // Simulate a keydown event to reuse the same logic
                    onKeyDown({ key: key });
                }
            }, { passive: false }); // passive: false is needed for preventDefault

            startGame();
        }

        function startGame() {
            // Create Snake
            snake = [];
            const head = createSnakePart(new THREE.Vector3(0, gridSize / 2, 0), true);
            snake.push(head);
            scene.add(head);
            
            // Set initial camera position
            cameraLookAtTarget.copy(head.position);
            updateCamera();


            // Create Food
            generateFood();
        }

        function resetGame() {
            // Clear old objects
            snake.forEach(part => scene.remove(part));
            scene.remove(food);

            // Reset variables
            score = 0;
            scoreElement.textContent = 'SCORE: 0';
            direction.set(1, 0, 0);
            gameOverModal.classList.add('hidden');
            
            // Restart
            startGame();
            animate();
        }

        function createSnakePart(position, isHead = false) {
            // Use SphereGeometry for a round snake part
            const geometry = new THREE.SphereGeometry(gridSize / 2, 16, 16); 
            const material = new THREE.MeshLambertMaterial({ color: isHead ? 0x48bb78 : 0x38a169 });
            const part = new THREE.Mesh(geometry, material);
            part.position.copy(position);
            part.castShadow = true;
            return part;
        }

        function generateFood() {
            const x = Math.floor(Math.random() * boardSize - boardSize / 2);
            const z = Math.floor(Math.random() * boardSize - boardSize / 2);
            const position = new THREE.Vector3(x + 0.5, gridSize / 2, z + 0.5);

            // Ensure food doesn't spawn on snake
            for(const part of snake) {
                if(part.position.distanceTo(position) < gridSize) {
                    generateFood(); // Recursively try again
                    return;
                }
            }
            
            // Food is still a cube
            const geometry = new THREE.BoxGeometry(gridSize, gridSize, gridSize);
            const material = new THREE.MeshLambertMaterial({ color: 0xe53e3e });
            food = new THREE.Mesh(geometry, material);
            food.position.copy(position);
            food.castShadow = true;
            scene.add(food);
        }

        function moveSnake() {
            const oldHeadPos = snake[0].position.clone();
            const newHeadPos = oldHeadPos.clone().add(direction.clone().multiplyScalar(gridSize));

            // Move body
            for (let i = snake.length - 1; i > 0; i--) {
                snake[i].position.copy(snake[i - 1].position);
            }

            // Move head
            snake[0].position.copy(newHeadPos);
            changingDirection = false;
        }

        function checkCollision() {
            const headPos = snake[0].position;

            // Wall collision
            const halfBoard = boardSize / 2;
            if (headPos.x >= halfBoard || headPos.x < -halfBoard || headPos.z >= halfBoard || headPos.z < -halfBoard) {
                return true;
            }

            // Self collision
            for (let i = 1; i < snake.length; i++) {
                if (headPos.distanceTo(snake[i].position) < gridSize) {
                    return true;
                }
            }
            return false;
        }

        function checkFood() {
            if (snake[0].position.distanceTo(food.position) < gridSize) {
                score += 10;
                scoreElement.textContent = 'SCORE: ' + score;

                // Add new part to snake
                const lastPart = snake[snake.length - 1];
                const newPart = createSnakePart(lastPart.position.clone());
                snake.push(newPart);
                scene.add(newPart);

                // Generate new food
                scene.remove(food);
                generateFood();
            }
        }
        
        function updateCamera() {
            if (snake.length > 0) {
                const headPosition = snake[0].position;
                
                // Define a fixed offset from the snake's head
                const cameraOffset = new THREE.Vector3(0, 15, 10);
                const targetPosition = headPosition.clone().add(cameraOffset);
                
                // Smoothly interpolate both the camera's position and its look-at point.
                camera.position.lerp(targetPosition, 0.08);
                cameraLookAtTarget.lerp(headPosition, 0.08);
                
                camera.lookAt(cameraLookAtTarget);
            }
        }

        // --- Animation Loop ---
        function animate(currentTime) {
            const gameIsOver = gameOverModal.classList.contains('hidden');
            if (!gameIsOver) return; // Stop the loop if modal is shown

            requestAnimationFrame(animate);

            const deltaTime = currentTime - lastUpdateTime;

            if (deltaTime > updateInterval) {
                lastUpdateTime = currentTime;
                
                moveSnake();
                if (checkCollision()) {
                    finalScoreElement.textContent = `YOUR SCORE: ${score}`;
                    gameOverModal.classList.remove('hidden');
                    return;
                }
                checkFood();
            }
            
            updateCamera();
            renderer.render(scene, camera);
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (changingDirection) return;

            const key = event.key;
            const currentDir = direction.clone();

            let newDir = null;

            if (key === 'ArrowUp' && currentDir.z !== gridSize) {
                newDir = new THREE.Vector3(0, 0, -1);
            } else if (key === 'ArrowDown' && currentDir.z !== -gridSize) {
                newDir = new THREE.Vector3(0, 0, 1);
            } else if (key === 'ArrowLeft' && currentDir.x !== gridSize) {
                newDir = new THREE.Vector3(-1, 0, 0);
            } else if (key === 'ArrowRight' && currentDir.x !== -gridSize) {
                newDir = new THREE.Vector3(1, 0, 0);
            }

            if (newDir) {
                // Prevent moving directly backward
                if (!currentDir.equals(newDir.clone().negate())) {
                    direction = newDir;
                    changingDirection = true;
                }
            }
        }

        // --- Start ---
        init();
        animate();
    </script>
</body>
</html>
